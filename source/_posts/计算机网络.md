---
title: 计算机网络
date: 2019-07-16 11:33:12
categories: 计算机网络
tags: 计算机网络
---

TCP/IP 协议族是一个四层协议系统，自底向上分别为链路层、网络层、运输层和应用层，每一层分别负责不同的通信功能。

<!-- more -->

## TCP/UDP

TCP和UDP协议位于四层模型的运输层。

### 简述TCP和UDP的区别

TCP提供可靠的通信传输，而UDP则常被用于广播和把细节控制交给应用的通信传输。两者的区别大致如下：

1. TCP是面向连接的，UDP是无连接的
2. TCP提供可靠的服务，UDP无法保证
3. TCP面向字节流，UDP面向报文
4. TCP数据传输速度慢，UDP传输速度快

> 面向报文的传输方式是应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则 IP 层需要分片，降低效率。若太短，会是 IP 太小。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。  
> TCP 是面向字节流的，它把上面应用层交下来的数据看成无结构的字节流来发送。应用数据被分割成 TCP 认为最适合发送的数据块。TCP还能提供流量控制。TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。


> 什么是保护消息边界和流呢？保护消息边界，就是指传输协议把数据当作一条独立的消息在网上传输,接收端只能接收独立的消息.也就是说存在保护消息边界，接收端一次只能接收发送端发出的一个数据包。而面向流则是指无保护消息保护边界的，如果发送端连续发送数据，接收端有可能在一次接收动作中，接收两个或者更多的数据包.

### TCP三次握手和四次挥手

TCP 通过三次握手来建立连接。三次握手的目标是使数据段的发送和接收同步。同时也向其他主机表明其一次可接收的数据量（窗口大小），并建立逻辑连接。

第一次握手，客户端发送连接请求，将 SYN(同步序号) 置1，Sequence Number 设为 x 并发送给服务端，然后，客户端进入 SYN_SEND 状态，等待服务器确认；
第二次握手，服务器收到客户端的请求，设置Acknowledgement Number为 x+1，同时将 SYN 置1，Sequence Number设为y。服务器将 SYN + ACK 字段放到一个报文中，发送给客户端，此时服务器进入 SYN_RECV 状态；
第三次握手，客户端接受到 SYN_ACK 报文，然后将 Acknowledgement Number 设置为y+1，向服务器发送 ACK 报文，之后客户端和服务器都进入 ESTABLISHED 状态，完成三次握手。

TCP 协议终止连接需要四次挥手。
首先进行关闭的一方（即发送第一个FIN）将执行主动关闭，而另一方执行被动关闭。
首先，主动关闭方发送 FIN 到被动方。
然后，被动方发回一个确认 ACK，确认收到的 seq。
第三次挥手来自被动方，被动方发送 FIN
到主动方。
最后，主动方收到 FIN 之后返回一个 ACK 确认，TCP连接到此终止。

![img1 align=center](计算机网络/tcp.png "TCP三次握手四次挥手")

**Q：为什么要三次握手**
A：为了实现数据的可靠传输，TCP 协议中，通信双方都必须有一个有序的消息队列，双方都要维护一个序列号，以标识发送出去的数据包。三次握手的过程即是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值的必经步骤。第一次握手，客户端将自己的序列号 Seq 告知服务器。第二次握手，服务器告诉客户端我已收到你的seq（acknowledge），同时发送服务器的 seq。 第三次握手，是客户端向服务器确认我已收到你的 seq 的过程。所以必须要有三次握手。

**Q：为什么要四次挥手**
A：因为 TCP 连接时全双工的，即数据在两个方向上能同时传递，A 可以发送给 B，反过来 B 也可以发送给 A。而终止一个方向的连接需要两次握手，一次FIN请求一次确认。所以终止连接总共需要四次握手。

### TCP 首部

如下表所示：

{% raw %}
<div style="text-align:center;">
<table>
    <tr>
        <td style="text-align: center;">16位源端口号</td> <td style="text-align: center;">16位目的端口号</td>
    </tr>
    <tr>
        <td colspan="2" style="text-align: center;">32位序号</td>
    </tr>
    <tr>
        <td colspan="2" style="text-align: center;">32位确认序号</td>
    </tr>
    <tr>
        <td style="text-align: center;">4位首部长度+保留6位+URG+ACK+PSH+RST+SYN+FIN</td> <td style="text-align: center;">16位窗口大小(一次可接收的数据量)</td>
    </tr>
    <tr>
        <td style="text-align: center;">16位检验和</td> <td style="text-align: center;">16位紧急指针</td>
    </tr>
    <tr>
        <td colspan="2" style="text-align: center;">选项</td>
    </tr>
    <tr>
        <td colspan="2" style="text-align: center;">数据</td>
    </tr>
</table>
</div>
{% endraw %}

**Q：为什么在TCP首部的开始便是源和目的的端口号？**
A：因为在IP地址A和B之间可以建立很多个TCP连接，为了高效的区别这些连接，就把端口号放在首部开始。


### TCP短连接、长连接和保活机制

TCP连接有长连接和短连接之分，短连接是指数据交互完毕后，主动释放连接，通常浏览器访问服务器的时候就是短连接。
长连接是指 client 和 server 完成一次交互之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接，数据库、通信软件的连接就是长连接。

长连接的环境下，进行一次数据交互后，很长一段时间内无数据交互时，客户端可能意外断电、崩溃、重启，这些 TCP 连接并未来得及正常释放，那么，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费，且有可能导致在一个无效的数据链路层面发送业务数据，结果就是发送失败。所以服务器端要做到快速感知失败，减少无效链接操作，这就有了 TCP 的Keepalive（保活探测）机制。

保活功能主要是为服务器应用程序提供的。服务器应用程序希望知道客户主机是否崩溃，从而可以回收相应的资源。

在连接空闲两个小时后，在一个连接上发送一个探查分组来完成保活功能。可能会发生 4 种不同的情况：
1. 客户端正常运行，服务器将保活定时器复位。
2. 客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的 TCP 都没有响应。服务器将不能够收到对探查的响应，并在 75 秒后超时。服务器总共发送 10 个这样的探查，每个间隔 75 秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。
3. 客户主机崩溃并已经重新启动。这时服务器将收到一个对其保活探查的响应，但是这
个响应是一个复位，使得服务器终止这个连接。
4. 客户主机正常运行，但是从服务器不可达。这与状态 2 相同，因为 TCP 不能够区分状态 4 与状态 2 之间的区别，它所能发现的就是没有收到探查的响应。

**Q：linux中，一个端口能接受TCP连接的数量是多少？**
A：理论上是没有上限的，但由于linux中一切都是文件，TCP连接的数量还是受限制的。
命令`ulimit -n`可以查看同一时间最多可开启的文件数，默认为1024。`ulimit -n NUMBER`可以修改该值为指定 NUMBER。


### TCP超时重传

对每个连接，TCP 管理 4 个不同的定时器：

1. 重传定时器使用于当希望收到另一端的确认。
2. 坚持(persist)定时器使窗口大小信息保持不断流动，即使另一端关闭了其接收窗口。
3. 保活(keepalive)定时器可检测到一个空闲连接的另一端何时崩溃或重启。
4. 2MSL定时器测量一个连接处于TIME_WAIT状态的时间。

在传输数据过程中： 
1. 主机 A 发送数据给主机 B，主机 B 没有收到数据包，丢包了  
2. 如果主机 A 在一个特定时间间隔内没有收到主机 B 发来的确认应答，就会认为发生了丢包，从而重发消息。   
 
也有这种可能： 
主机 B 收到了数据包，它发送 ACK 确认包时，主机 A 未能接收到，丢包了。
这时，主机 A 认为主机 B 没有接收到数据包。会发生重传。





## IP层

**Q：在浏览器中输入网址执行之后会发生什么？**
A：首先，浏览器通过 DNS 解析出域名的 IP 地址，然后浏览器发起一个到该 IP 地址的 HTTP 会话，然后通过运输层的 TCP 协议封装数据包，传入网络层。网络层将会话请求封装成报文段，添加源和目的端口，然后在 IP 层查找目的端。通过查找路由表，数据报被发送到服务器。


