---
title: Redis 学习笔记
date: 2019-06-14 16:11:53
categories: 数据库
tags: [数据库,Redis]
---

Redis 学习笔记，不定期更新。
<!--more-->

## 书籍及源码

书籍：
+ 《Redis设计与实现》

代码：  
+ [Redis 源码](https://github.com/antirez/redis/)  
+ [《Redis设计与实现》Redis源码注释](https://github.com/huangz1990/redis-3.0-annotated)  
+ [如何阅读 Redis 源码](http://blog.huangz.me/diary/2014/how-to-read-redis-source-code.html)


## 一. redis 常见应用场景

来源：https://www.jianshu.com/p/40dbc78711c8

1. 热点数据的缓存  
由于 redis 访问速度块、支持的数据类型比较丰富，所以 redis 很适合用来存储热点数据，另外结合 expire，我们可以设置过期时间然后再进行缓存更新操作，这个功能最为常见，我们几乎所有的项目都有所运用。

2. 限时业务的运用  
redis 中可以使用 expire 命令设置一个键的生存时间，到时间后 redis 会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。

3. 计数器相关问题  
redis 由于 incrby 命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。

4. 排行榜相关问题  
关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助 redis 的 SortedSet 进行热点数据的排序。在奶茶活动中，我们需要展示各个部门的点赞排行榜，所以我针对每个部门做了一个 SortedSet，然后以用户的 openid 作为上面的 username，以用户的点赞数作为上面的 score，然后针对每个用户做一个 hash，通过 zrangebyscore 就可以按照点赞数获取排行榜，然后再根据 username 获取用户的 hash 信息，这个当时在实际运用中性能体验也蛮不错的。  

5. 分布式锁  
这个主要利用 redis 的 setnx 命令进行，setnx："set if not exists"就是如果不存在则成功设置缓存同时返回1，否则返回0，这个特性在俞你奔远方的后台中有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过 setnx 设置一个 lock，如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个 lock 加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间 就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。当然我们可以将这个特性运用于其他需要分布式锁的场景中，结合过期时间主要是防止死锁的出现。

6. 延时操作  
这个目前我做过相关测试，但是还没有运用到我们的实际项目中，下面我举个该特性的应用场景。 比如在订单生产后我们占用了库存，10分钟后去检验用户是够真正购买，如果没有购买将该单据设置无效，同时还原库存。 由于 redis 自2.8.0之后版本提供 Keyspace Notifications 功能，允许客户订阅 Pub/Sub 频道，以便以某种方式接收影响 Redis 数据集的事件。所以我们对于上面的需求就可以用以下解决方案，我们在订单生产时，设置一个 key，同时设置 10 分钟后过期， 我们在后台实现一个监听器，监听 key 的实效，监听到 key 失效时将后续逻辑加上。 当然我们也可以利用 rabbitmq、activemq 等消息中间件的延迟队列服务实现该需求。

7. 分页、模糊搜索  
redis 的 set 集合中提供了一个 zrangebylex 方法，语法如下：ZRANGEBYLEX key min max [LIMIT offset count] 通过ZRANGEBYLEX zset - + LIMIT 0 10 可以进行分页数据查询，其中- +表示获取全部数据zrangebylex key min max 这个就可以返回字典区间的数据，利用这个特性可以进行模糊查询功能，这个也是目前我在redis中发现的唯一一个支持对存储内容进行模糊查询的特性。前几天我通过这个特性，对学校数据进行了模拟测试，学校数据60万左右，响应时间在700ms左右，比mysql的like查询稍微快一点，但是由于它可以避免大量的数据库io操作，所以总体还是比直接mysql查询更利于系统的性能保障。

8. 点赞、好友等相互关系的存储  
Redis set 对外提供的功能与 list 类似是一个列表的功能，特殊之处在于 set 是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。又或者在微博应用中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。这个在奶茶活动中有运用，就是利用 set 存储用户之间的点赞关联的，另外在点赞前判断是否点赞过就利用了 sismember 方法，当时这个接口的响应时间控制在 10 毫秒内，十分高效。

9. 队列  
由于 redis 有 list push 和 list pop 这样的命令，所以能够很方便的执行队列操作。




## 二. redis 支持的数据类型

### 1. 字符串(String)

### 2. 字典(Hash)

### 3. 列表(List)

### 4. 集合(Set)

Redis 的数据库就是使用**字典**来作为底层实现的。举个例子，如果客户端执行命令：`set msg "hello world"`，那么 Redis 将在数据库创建一个新的键值对，其中键是一个字符串对象，其底层实现是一个保存着字符串"msg"的SDS，值也是一个字符串对象，其底层实现是一个保存这字符串"hello world"的 SDS。

redis 的 set 是 **string 类型**的无序集合。
redis 中集合是通过**哈希表**实现的，所以增删查改的复杂度都是 O(1)。

集合有两个特别好用的地方：判断一个元素是否集合的成员；返回两个集合的交集。

常用命令：
``` bash
SADD key value  # 新建或添加元素到名为key的集合中
SCARD key  # 返回名为key的集合中元素的个数
SMEMBERS key  # 返回集合中的所有成员
SINTER key1 key2  # 返回key1和key2两个集合的交集
SISMEMBER　key elem  # 判断elem是否是集合key的成员
SREM key member  # 移除集合key中的一个成员member
```

### 5. 有序集合(ZSet)

